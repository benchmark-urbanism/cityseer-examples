---
title: Python 101
editor:
  render-on-save: true
---

Python is a versatile language, widely used for urban analysis and data science. This guide introduces its foundational concepts.

The best way to learn Python is by trying things out. Change the examples, break them, and see what happens. Progress comes fastest when you actively use the tools to solve problems and learn as you go.

What follows is a brief introduction to Python. To use it effectively day-to-day, you need hands-on practice and further resources, which are widely available online. Large language models can help speed up the process and answer questions, but use them to amplify your understanding, not as a substitute for learning. Otherwise, you miss opportunities to fully grasp the tools' potential.

### Comments

Use `#` to add comments, which Python ignores. Comments explain your code.

```{python}
# This is a comment
print("Hello, World!")  # Print a greeting
```

Multiline comments use triple quotes:

```python
"""
This is a multiline comment.
It can span multiple lines.
"""
```

### Variables

Variables act as labeled containers for data. Assign values using `=`.

```{python}
# Assigning values to variables
message = "Hello, Python!"  # Text (string)
count = 10                  # Whole number (integer)
price = 19.99               # Decimal number (float)
is_active = False           # True/False value (boolean)

# Accessing variable values
print(message)
print(count)
print(price)
print(is_active)
```

### Data Types

Variables can be one of several types, such as numbers (integers or floats) and text (strings). Functionality is specific to types. While some functionality is shared across types, other behaviours are type-specific.

- **`str` (String):** Text, enclosed in quotes (`"` or `'`). Example: `"Urbanism"`.
- **`int` (Integer):** Whole numbers. Example: `42`, `-7`.
- **`float` (Float):** Numbers with decimals. Example: `3.14`, `-0.001`.
- **`bool` (Boolean):** Logical values, `True` or `False` (capitalised).

Check a variable's type using `type()`:

```{python}
print(type(message))   # <class 'str'>
print(type(count))     # <class 'int'>
print(type(price))     # <class 'float'>
print(type(is_active)) # <class 'bool'>
```

When working with variables, especially in Python, be cognisant of the type assigned to the variable. Misusing types can lead to issues and errors.

```python
# This will raise an error because you cannot add a string to an integer
# TypeError: unsupported operand type(s) for +: 'int' and 'str'

count + message
```

### Arithmetic

Python supports standard arithmetic operations:

```{python}
# Arithmetic operators: +, -, *, /, **, %
a = 10
b = 3

print(a + b)  # Addition: 13
print(a - b)  # Subtraction: 7
print(a * b)  # Multiplication: 30
print(a / b)  # Division (float result): 3.333...
print(a ** b) # Exponentiation: 1000
print(a % b)  # Modulus (remainder): 1
```

Python adheres to the standard order of operations: Parentheses, Exponents, Multiplication and Division (from left to right), Addition and Subtraction (from left to right). For example:

```{python}
result = 2 + 3 * 4 - 5 / 2
print(result)
```

Use brackets explicitly to make your intention clear if you are in any way uncertain about the order of operations.

```{python}
result = (2 + 3) * 4 - 5 / 2
print(result)
```

```{python}
result = 2 + 3 * (4 - 5) / 2
print(result)
```

### Strings

Strings are very versatile and have a number of built-in methods for common use cases.

```{python}
first_name = "Ada"
last_name = "Lovelace"
full_name = first_name + " " + last_name
print(full_name)  # Output: Ada Lovelace
```

::: {.callout-note}

A method is a function (which we'll cover in more detail later) that belongs to an object or type such as a string. For example, `str.upper()` is a method of the `str` class that converts a string to uppercase. You access methods using dot notation (`object.method()`) and execute them by using parentheses. If a method requires options or parameters, they go inside the parentheses.

:::

Some common built-in methods include converting text to lower or upper case or removing leading or trailing characters.

```{python}
# String methods
print(full_name.lower())  # Lowercase: "ada lovelace"
print(full_name.upper())  # Uppercase: "ADA LOVELACE"
print(full_name.replace(" ", "_"))  # Replace spaces with underscores
```

#### F-Strings

F-strings simplify string formatting by embedding variables directly. Use `f` before the opening quote and `{}` for variable placeholders, which will be replaced with the variable's value when the string is printed.

```{python}
city = "Berlin"
population = 3800000
info = f"The city of {city} has a population of {population}."
print(info)
```

### Exercises

- Create a variable for a number. Print its type using `type()`.
- Create a variable for your name, then print a statement using an F-string to say "Hello, [your name]!".
- Perform all basic arithmetic operations (+, -, \*, /, %) on two numbers and print the results. Experiment with brackets to change the order of operations.

## Collections

Often, you need to work with multiple pieces of data at once. Python provides several ways to group data, each with its own characteristics.

| Type       | Ordered | Unique       | Mutable | Example Syntax     | Use Case Example              |
| ---------- | ------- | ------------ | ------- | ------------------ | ----------------------------- |
| List       | Yes     | No           | Yes     | `[1, 2, 3]`        | Shopping list, coordinates    |
| Tuple      | Yes     | No           | No      | `(1, 2, 3)`        | Fixed coordinates, RGB colour |
| Set        | No      | Yes (Values) | Yes     | `{1, 2, 3}`        | Unique tags, deduplication    |
| Dictionary | Yes     | Yes (Keys)   | Yes     | `{"a": 1, "b": 2}` | Lookup tables, data records   |

### Lists

Use lists when the order of items matters and you might need to change the items later. Lists are mutable, which means they behave like a row of mailboxes. You can put content into the mailbox and take content out, but the mailbox stays where it is and can be updated in place. To access the contents of a list, use square brackets with the index (address) of the list item (mailbox). The index is based on zero for the first item. You can also reverse index by using a negative symbol, in which case `-1` represents the last item in the list.

Create a list using square brackets []:

```{python}
planets = ["Mercury", "Venus", "Earth", "Mars"]

planets
```

Access items by index (position, starting from 0)

```{python}
print(planets[0]) # Mercury
print(planets[2]) # Earth
```

Reverse index

```{python}
planets[-1] # Mars
planets[-3] # Venus
```

Add an item to the end

```{python}
planets.append("Jupiter")

planets
```

::: {.callout-note}

Python contains several built-in methods, one of those is called `len` which we will use below: it returns the length of an item such as a list or a string.

:::

Get the number of items

```{python}
len(planets) # Output: 5
```

Lists are mutable (can be changed after creation)

```{python}
planets[0] = "Fast Planet" # Change the first item
planets[3] = "Red Planet" # Update Mars

planets
```

Common list operations

```{python}
planets.insert(1, "New Planet") # Insert at a specific index
print(planets)
```

Remove item at index 2 and get its value

```{python}
removed_planet = planets.pop(2)
print(f"Removed: {removed_planet}")
print(planets)
```

### Dictionaries

Use dictionaries when you need to look up values based on a unique key (like looking up a word's definition in a dictionary). Dictionaries are powerful data structures because you can use the key to reference a value.

Once you have structured data in a dictionary, you can later retrieve a particular value based on the associated key, or update the value associated with a key. This is similar to how you would look up a word in a dictionary to find its definition. The key is the word, and the value is the definition.

Dictionaries are defined using curly braces `{}`. Each item is a key-value pair, separated by a colon `:`. The key is on the left, and the value is on the right.

Like lists, dictionaries use square bracket notation for indexing, but in this case, instead of using an integer for the position of an item, you use the key itself.

```{python}
# Create a dictionary using curly braces {}
# Format: {key1: value1, key2: value2}
building_info = {
    "type": "Residential",
    "floors": 5,
    "year_built": 1998
}
building_info
```

```{python}
# Access values using keys
print(building_info["type"]) # Residential
print(building_info["floors"]) # 5

```

```{python}
# Add a new key-value pair
building_info["has_elevator"] = True
print(building_info)
```

```{python}
# Dictionaries are mutable
building_info["year_built"] = 2000 # Update a value
print(building_info)
```

```{python}
# Common dictionary operations
print(building_info.keys())   # Get all keys
print(building_info.values()) # Get all values
print(building_info.get("address", "Not specified")) # Get value, provide default if key not found
```

### Tuples

Use tuples when you have a fixed collection of items whose order matters and should not change after creation (like coordinates). Tuples are immutable, meaning they cannot be changed after creation.

```{python}
# A tuple of coordinates
point = (10.5, 25.3)
print(point)
print(point[0]) # Access items like lists
```

```python
# point[0] = 11.0 # This would cause a TypeError! Tuples are immutable.
```

```{python}
# Tuples are often used to return multiple values from functions or for unpacking
def get_coordinates():
    return (10.5, 25.3)
```

```{python}
coords = get_coordinates()
lat, lon = coords # Tuple unpacking
print(f"Latitude: {lat}, Longitude: {lon}")
```

### Sets

Use sets when you only care about the presence or absence of unique items, and order doesn't matter.

```{python}
 # Duplicate "London" is ignored
unique_cities = {"London", "Paris", "Berlin", "London"}
# Output might be in any order, e.g., {'Berlin', 'London', 'Paris'}
print(unique_cities)
```

```{python}
# Check for membership
print("Paris" in unique_cities) # True
```

```{python}
# Add an item
unique_cities.add("Rome")
print(unique_cities)
```

```{python}
# Set operations
set1 = {1, 2, 3}
set2 = {3, 4, 5}
print(set1.union(set2))        # All items from both: {1, 2, 3, 4, 5}
print(set1.intersection(set2)) # Items in both: {3}
print(set1.difference(set2))   # Items in set1 but not set2: {1, 2}
```

## Control Flow

Control flow structures are the backbone of programming logic. They let you make decisions based on data (`if`/`elif`/`else`) and repeat actions (`for`/`while`).

### Conditionals

Conditionals allow your program to execute different blocks of code based on whether certain conditions are `True` or `False`. They use comparison operators to evaluate conditions.

```{python}
# Comparison operators return boolean values
print(5 == 5) # Equal to: True
print(5 != 3) # Not equal to: True
print(5 > 3)  # Greater than: True
print(5 < 3)  # Less than: False
print(5 >= 5) # Greater than or equal to: True
print(5 <= 3) # Less than or equal to: False
```

::: {.callout-note}

### Indentation

Indentation is non-negotiable in Python. It indicates which code belongs to which block. Use consistent spaces or tabs (not both) to indent code inside conditionals, loops, and functions. Typically, either two or four spaces are used—whichever you pick, be consistent. You will also notice that blocks are introduced with colons (`:`), which indicate the starting point of an indented block. There can be nested indentation in cases where multiple loops or conditions are nested.

```{python}
# Example of indentation
for i in range(3):
    if i == 2:
        print(f"{i} is two")
    else:
        print(f"{i} is not two")
```

:::

Use `if`, `elif` (else if), and `else` to control which code runs. You can further use the `or` and `and` statements to combine conditionals, or the `is` and `is not` to check if a value is `True`, `False`, or `None`.

```{python}
population_density = 5000 # people per sq km

if population_density > 10000:
    print("Very high density")
elif population_density > 3000:
    print("High density")
elif population_density > 1000:
    print("Medium density")
else:
    print("Low density")
```

```{python}
# Combining conditions with 'and', 'or'
floors = 12

if population_density > 3000 and floors > 10:
    print("High density and tall buildings")
```

```{python}
# Checking for None (often used for missing data)
maybe_data = None # Represents absence of a value

if maybe_data is None:
    print("Data is missing.")
else:
    print(f"Data found: {maybe_data}")
```

Conditional logic allows your program to adapt its behaviour based on different situations.

### Loops

Loops save you from writing the same code over and over. They are indispensable for working with collections and can be combined with conditionals to selectively apply logic based on the value of the currently iterated item.

#### `for` Loops

Use `for` to go through each item in a sequence (like a list, tuple, string, or dictionary keys/items). In each iteration of the loop, the variable specified after `for` (e.g., `planet` in the example below) is automatically updated to hold the current item from the sequence.

```{python}
# Loop through a list
for planet in planets:
    print(f"Checking planet: {planet}")
```

#### `while` Loops

Use `while` when you don't know exactly how many times to loop in advance, but you know the condition under which the loop should continue running.

```{python}
# Countdown
countdown = 3
while countdown > 0:
    print(countdown)
    # Decrease countdown (essential to avoid infinite loop!!!)
    countdown = countdown - 1
print("Blast off!")
```

**Caution:** Ensure the `while` loop's condition eventually becomes `False`, otherwise it will run forever (an infinite loop)!

### Exercise

Create a list of numbers from one to 10 and assign this to a variable called `numbers`. Then, loop through your list of numbers. For each number, check if it is even. If it is, print the number.

**Hint:** Python has an operator called the modulo (`%`) which gives the remainder after division. You can check if a number is even by seeing if the remainder when dividing by two is zero (e.g., `if number % 2 == 0: do something`).

## Functions

Functions help organise code into logical, reusable units. This makes programs easier to read, debug, and maintain. If you find yourself copying and pasting code, consider using a function instead.

```{python}
# Define a function with parameters (inputs)
def calculate_density(population, area, unit="sq km"):
    """Calculates population density.

    It is good practice to use a documentation block or string to explain what
    parameters your function expects, what it does, and what types of values it returns.

    Args:
        population (int): The total population.
        area (float): The total area.
        unit (str, optional): The unit for the area. Defaults to "sq km".

    Returns:
        float: The calculated density, or 0 if area is non-positive.
    """
    if area <= 0:
        print("Area must be positive to calculate density.")
        return 0 # Return 0 or raise an error for invalid input
    density = population / area
    return density

# Call the function with arguments (values for the parameters)
density1 = calculate_density(1000000, 50)
print(f"Density 1: {density1:.2f} people per sq km")

density2 = calculate_density(population=500000, area=100, unit="square kilometres") # Can name arguments
print(f"Density 2: {density2:.2f} people per square kilometres")

# Example of invalid input
density_invalid = calculate_density(1000, 0)
print(f"Density invalid: {density_invalid}")
```

```{python}
# Call the function with arguments (values for the parameters)
density1 = calculate_density(1000000, 50)
print(f"Density 1: {density1:.2f} people per sq km")
```

```{python}
# Can name arguments
density2 = calculate_density(
    population=500000, area=100, unit="square kilometres"
)
print(f"Density 2: {density2:.2f} people per square kilometres")
```

```{python}
# Example of invalid input
density_invalid = calculate_density(1000, 0)
print(f"Density invalid: {density_invalid}")
```

**Key Ideas:**

- **Parameters:** Variables listed inside the parentheses in the function definition (`population`, `area`, `unit`).
- **Arguments:** Values passed to the function when it is called (`1000000`, `50`).
- **Default Arguments:** Parameters can have default values (`unit="sq km"`). If an argument isn't provided for it when calling, the default is used.
- **Scope:** Variables defined _inside_ a function (like `density`) generally only exist within that function.
- **Docstrings:** The triple-quoted string `"""..."""` right after the `def` line is a docstring. It explains what the function does, its arguments (`Args:`), and what it returns (`Returns:`). Writing good docstrings is crucial for understandable code.
- **Return Statement:** The `return` statement sends a value back to the caller. If no return is specified, the function returns `None`.

Functions help make code modular, easier to test, and simpler to understand. Returning a result from the function is optional but typically the case and unless the function is doing a one off task such as printing a line.

## Importing Modules

No need to reinvent the wheel! Python's modules provide ready-made tools. If you see an unfamiliar function, check if it comes from an import at the top of the file.

```{python}
import math # Import the built-in math module

radius = 5
area = math.pi * (radius ** 2) # Use math.pi
print(f"Circle Area: {area:.2f}")
```

```{python}
circumference = 2 * math.pi * radius
print(f"Circle Circumference: {circumference:.2f}")
```

```{python}
# You can also import specific methods from a module
from math import sqrt # Import only the square root function
print(f"Square root of 16 is {sqrt(16)}")
```

**Key Idea:** `import module_name` makes the functions and variables within that module available, accessed via `module_name.function_name`.

Later sections will heavily rely on importing powerful libraries like `pandas`, `geopandas`, and `cityseer`.

## Common Errors

Errors are normal! Learning to read the messages is key to fixing them. If you get stuck, try searching for the error message online—-chances are, someone else has had the same problem. Alternatively, ask a Large Language Model (LLM) to help decipher the error messages.

- **`NameError: name '...' is not defined`**: You tried to use a variable before assigning a value to it, or you misspelled the variable name.
- **`TypeError: unsupported operand type(s) for ...`**: You tried to perform an operation on incompatible data types (e.g., adding a string to an integer: `"Hello" + 5`).
- **`SyntaxError: invalid syntax`**: You made a mistake in the Python grammar (e.g., missing colon `:`, mismatched parentheses `()`).
- **`IndexError: list index out of range`**: You tried to access an item in a list using an index that doesn't exist (e.g., accessing `my_list[5]` when the list only has 3 items).
- **`ImportError: No module named '...'` or `ModuleNotFoundError: No module named '...'`**: You tried to import a module that Python can't find. It might be misspelled or not installed.

**Debugging Tip:** If you get an error, read the _last_ line first (it usually has the specific error type and message). Then look at the line numbers mentioned to trace where the problem occurred. Use `print()` statements inside your code to check the values of variables at different points. If you fix one error and another appears, that's normal—fix errors one at a time.
