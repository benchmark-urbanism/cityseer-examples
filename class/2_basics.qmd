---
title: Python 101
---

Python is a versatile language, widely used for urban analysis and data science. This guide introduces its foundational concepts, essential for practical applications. Mistakes are part of the learning process—experiment freely.

### Variables: Containers for Data

Variables act as labeled containers for data, enabling reuse and clarity in code.

```{python}
# Assigning values to variables
message = "Hello, Python!"  # Text (string)
count = 10                  # Whole number (integer)
price = 19.99               # Decimal number (float)
is_active = False           # True/False value (boolean)

# Accessing variable values
print(message)
print(count)
print(price)
print(is_active)
```

**Note:** Use the equals sign (`=`) to assign values. Variables enhance readability and reusability.

### Data Types: Understanding Information

Python categorizes data into types, each with specific behaviors:

- **`str` (String):** Text, enclosed in quotes (`"` or `'`). Example: `"Urbanism"`.
- **`int` (Integer):** Whole numbers. Example: `42`, `-7`.
- **`float` (Float):** Numbers with decimals. Example: `3.14`, `-0.001`.
- **`bool` (Boolean):** Logical values, `True` or `False` (capitalized).

Check a variable's type using `type()`:

```{python}
print(type(message))   # <class 'str'>
print(type(count))     # <class 'int'>
print(type(price))     # <class 'float'>
print(type(is_active)) # <class 'bool'>
```

Understanding types is crucial for effective data manipulation.

### Arithmetic: Python as a Calculator

Python supports standard arithmetic operations:

```{python}
# Arithmetic operators: +, -, *, /, **, %
a = 10
b = 3

print(a + b)  # Addition: 13
print(a - b)  # Subtraction: 7
print(a * b)  # Multiplication: 30
print(a / b)  # Division (float result): 3.333...
print(a ** b) # Exponentiation: 1000
print(a % b)  # Modulus (remainder): 1
```

Python adheres to the standard order of operations (PEMDAS/BODMAS).

### Strings: Managing Text

Strings are sequences of characters, essential for handling textual data.

#### Concatenation: Combining Strings

```{python}
first_name = "Ada"
last_name = "Lovelace"
full_name = first_name + " " + last_name
print(full_name)  # Output: Ada Lovelace
```

#### F-Strings: Embedding Variables in Text

F-strings simplify string formatting by embedding variables directly:

```{python}
city = "Berlin"
population = 3700000
info = f"The city of {city} has a population of {population}."
print(info)
```

**Tip:** Use `f` before the opening quote and `{}` for variable placeholders. F-strings are efficient and clear.

### Exercises: Practice and Apply

#### Exercise 1.2: Data Types and Variables

1. Create a variable for your favorite number. Print its type using `type()`.
2. Write a sentence about your favorite hobby using an f-string. Print the result.
3. Define a boolean variable indicating whether you like Python. Print its value.

#### Exercise 1.3: Arithmetic and Strings

1. Perform all basic arithmetic operations (+, -, \*, /, %, \*\*) on two numbers and print the results.

#### Exercise 1.4: Collections

1. Create a list of your top 5 favorite movies. Print the list and its length.
2. Create a dictionary to store information about your favorite book (e.g., title, author, year). Print each key-value pair using a loop.
3. Create a set of unique colors you like. Add a new color to the set and print the updated set.

---

## Working with Collections

Often, you need to work with multiple pieces of data at once. Python provides several ways to group data, each with its own characteristics. Choosing the right one makes your code easier to write and understand.

| Type       | Ordered | Unique Items | Example Syntax     | Use Case Example             |
| ---------- | ------- | ------------ | ------------------ | ---------------------------- |
| List       | Yes     | No           | `[1, 2, 3]`        | Shopping list, coordinates   |
| Tuple      | Yes     | No           | `(1, 2, 3)`        | Fixed coordinates, RGB color |
| Set        | No      | Yes          | `{1, 2, 3}`        | Unique tags, deduplication   |
| Dictionary | No      | Keys unique  | `{"a": 1, "b": 2}` | Lookup tables, data records  |

#### Lists: Ordered Sequences

Use lists when the order of items matters and you might need to change the items later.

```{python}
# Create a list using square brackets []
planets = ["Mercury", "Venus", "Earth", "Mars"]
print(planets)

# Access items by index (position, starting from 0)
print(planets[0]) # Mercury
print(planets[2]) # Earth

# Change an item
planets[3] = "Red Planet" # Update Mars
print(planets)

# Add an item to the end
planets.append("Jupiter")
print(planets)

# Get the number of items
print(len(planets)) # Output: 5

# Lists are mutable (can be changed after creation)
planets[0] = "Fast Planet" # Change the first item
print(planets)

# Common list operations
planets.insert(1, "New Planet") # Insert at a specific index
print(planets)
removed_planet = planets.pop(2) # Remove item at index 2 and get its value
print(f"Removed: {removed_planet}")
print(planets)
```

#### Dictionaries: Unordered Key-Value Pairs

Use dictionaries when you need to look up values based on a unique key (like looking up a word's definition).

```{python}
# Create a dictionary using curly braces {}
# Format: {key1: value1, key2: value2}
building_info = {
    "type": "Residential",
    "floors": 5,
    "year_built": 1998
}
print(building_info)

# Access values using keys
print(building_info["type"]) # Residential
print(building_info["floors"]) # 5

# Add a new key-value pair
building_info["has_elevator"] = True
print(building_info)

# Dictionaries are mutable
building_info["year_built"] = 2000 # Update a value
print(building_info)

# Common dictionary operations
print(building_info.keys())   # Get all keys
print(building_info.values()) # Get all values
print(building_info.get("address", "Not specified")) # Get value, provide default if key not found
```

#### Tuples: Ordered Sequences (Fixed Records)

Use tuples when you have a fixed collection of items whose order matters and should not change after creation (like coordinates).

```{python}
# A tuple of coordinates
point = (10.5, 25.3)
print(point)
print(point[0]) # Access items like lists

# point[0] = 11.0 # This would cause a TypeError! Tuples are immutable.

# Tuples are often used to return multiple values from functions
def get_coordinates():
    return (10.5, 25.3)

coords = get_coordinates()
print(f"Latitude: {coords[0]}, Longitude: {coords[1]}")
```

#### Sets: Unordered Collections of Unique Items

Use sets when you only care about the presence or absence of unique items, and order doesn't matter.

```{python}
unique_cities = {"London", "Paris", "Berlin", "London"} # Duplicate "London" is ignored
print(unique_cities) # Output might be in any order, e.g., {'Berlin', 'London', 'Paris'}

# Check for membership
print("Paris" in unique_cities) # True

# Add an item
unique_cities.add("Rome")
print(unique_cities)

# Set operations
set1 = {1, 2, 3}
set2 = {3, 4, 5}
print(set1.union(set2))        # All items from both: {1, 2, 3, 4, 5}
print(set1.intersection(set2)) # Items in both: {3}
print(set1.difference(set2))   # Items in set1 but not set2: {1, 2}
```

---

## Control Flow: Loops and Conditionals

Loops and conditionals are the backbone of programming logic. They let you repeat actions and make decisions based on data.

### Loops: Repeating Actions Efficiently

Loops save you from writing the same code over and over. They are essential for working with collections.

#### `for` Loop: Iterate Over Sequences

Use `for` to go through each item in a list, dictionary (keys), or other sequence.

```{python}
# Loop through a list
for planet in planets:
    print(f"Checking planet: {planet}")

# Loop through dictionary keys
for key in building_info:
    print(f"Property: {key}, Value: {building_info[key]}")

# Loop through dictionary items (key-value pairs)
print("\nBuilding Details:")
for key, value in building_info.items(): # Use .items() for key-value pairs
    print(f"- {key}: {value}")

# Loop a specific number of times
for i in range(5): # range(5) generates numbers 0, 1, 2, 3, 4
    print(f"Loop iteration {i}")
```

#### `while` Loop: Repeat While a Condition is True

Use `while` when you don't know exactly how many times to loop, but you know the condition to stop.

```{python}
# Countdown
countdown = 3
while countdown > 0:
    print(countdown)
    countdown = countdown - 1 # Decrease countdown
print("Blast off!")
```

**Caution:** Ensure the `while` loop's condition eventually becomes `False`, otherwise it will run forever (infinite loop)!

Loops are essential for processing collections of data or performing tasks multiple times without rewriting code.

### Conditionals: Making Decisions (`if`, `elif`, `else`)

These statements control which code runs based on whether conditions are `True` or `False`.

```{python}
population_density = 5000 # people per sq km

if population_density > 10000:
    print("Very high density")
elif population_density > 3000: # elif = else if
    print("High density")
elif population_density > 1000:
    print("Medium density")
else:
    print("Low density")

# Combining conditions with 'and', 'or'
if population_density > 3000 and building_info["floors"] > 10:
    print("High density and tall buildings")

# Checking for None (often used for missing data)
maybe_data = None # Represents absence of a value

if maybe_data is not None:
    print(f"Data found: {maybe_data}")
else:
    print("Data is missing.")
```

Conditional logic allows your program to adapt its behavior based on different situations.

### Exercise 1.5: Error Handling and List Comprehensions

1. Write a program that prints the square of a number. Handle invalid inputs gracefully.
2. Create a list of the first 10 even numbers using a list comprehension.

---

## Functions: Creating Reusable Code Blocks

Functions help organize code into logical, reusable units. This makes programs easier to read, debug, and maintain. If you find yourself copying and pasting code, consider using a function instead.

```{python}
# Define a function with parameters (inputs)
def calculate_density(population, area, unit="sq km"):
    """Calculates population density.

    Args:
        population (int): The total population.
        area (float): The total area.
        unit (str, optional): The unit for the area. Defaults to "sq km".

    Returns:
        float: The calculated density, or 0 if area is non-positive.
    """
    if area <= 0:
        return 0
    density = population / area
    print(f"Calculating density for area unit: {unit}") # Show usage of unit
    return density

# Call the function with arguments (values for the parameters)
density1 = calculate_density(1000000, 50)
density2 = calculate_density(population=500000, area=100, unit="square kilometers") # Can name arguments

print(f"Density 1: {density1:.2f} people/sq km")
print(f"Density 2: {density2:.2f} people/square kilometers")
```

**Key Ideas:**

- **Parameters:** Variables listed inside the parentheses in the function definition (`population`, `area`, `unit`).
- **Arguments:** Values passed to the function when it is called (`1000000`, `50`).
- **Default Arguments:** Parameters can have default values (`unit="sq km"`). If an argument isn't provided for it when calling, the default is used.
- **Scope:** Variables defined _inside_ a function (like `density`) generally only exist within that function.
- **Docstrings:** The triple-quoted string `"""..."""` right after the `def` line is a docstring. It explains what the function does, its arguments (`Args:`), and what it returns (`Returns:`). Writing good docstrings is crucial for understandable code.

Functions help make code modular, easier to test, and simpler to understand.

---

## Importing Modules: Using External Code

No need to reinvent the wheel! Python's modules provide ready-made tools. If you see an unfamiliar function, check if it comes from an import at the top of the file.

```{python}
import math # Import the built-in math module

radius = 5
area = math.pi * (radius ** 2) # Use math.pi and math.pow()
circumference = 2 * math.pi * radius

print(f"Circle Area: {area:.2f}")
print(f"Circle Circumference: {circumference:.2f}")

# You can also import specific things
from math import sqrt # Import only the square root function
print(f"Square root of 16 is {sqrt(16)}")
```

**Key Idea:** `import module_name` makes the functions and variables within that module available, accessed via `module_name.function_name`.

Later sections will heavily rely on importing powerful libraries like `pandas`, `geopandas`, and `cityseer`.

---

## Common Beginner Errors (and How to Read Them)

Errors are normal! Learning to read the messages is key to fixing them. If you get stuck, try searching for the error message online—chances are, someone else has had the same problem.

- **`NameError: name '...' is not defined`**: You tried to use a variable before assigning a value to it, or you misspelled the variable name.
- **`TypeError: unsupported operand type(s) for ...`**: You tried to perform an operation on incompatible data types (e.g., adding a string to an integer: `"Hello" + 5`).
- **`SyntaxError: invalid syntax`**: You made a mistake in the Python grammar (e.g., missing colon `:`, mismatched parentheses `()`).
- **`IndexError: list index out of range`**: You tried to access an item in a list using an index that doesn't exist (e.g., accessing `my_list[5]` when the list only has 3 items).
- **`ImportError: No module named '...'` or `ModuleNotFoundError: No module named '...'`**: You tried to import a module that Python can't find. It might be misspelled or not installed.

**Debugging Tip:** If you get an error, read the _last_ line first (it usually has the specific error type and message). Then look at the line numbers mentioned to trace where the problem occurred. Use `print()` statements inside your code to check the values of variables at different points. If you fix one error and another appears, that's normal—fix errors one at a time.

#### Error Handling: Dealing with Mistakes Gracefully

Errors can occur in your code. Python provides a way to handle them using `try` and `except` blocks.

```{python}
try:
    number = int("42") # Example of valid input
    print(f"You entered: {number}")
except ValueError:
    print("That's not a valid number!")
```

#### List Comprehensions: Compact Loops

List comprehensions provide a concise way to create lists.

```{python}
squares = [x**2 for x in range(10)]
print(squares) # Output: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

---

## Practice and Experimentation

The best way to learn Python is by trying things out. Change the examples, break them, and see what happens. If you don't understand something, add a `print()` statement or try a small experiment in a new cell.

---

### Summary & Next Steps

Congratulations! You've expanded your Python toolkit:

- Storing data (`variables`, `types`)
- Calculations (`operators`)
- Working with text (`strings`, `f-strings`)
- Grouping data (`lists`, `dictionaries`, **tuples**, **sets**)
- Repeating tasks (`loops`)
- Making decisions (`conditionals`)
- Organizing code (`functions`, **docstrings**, **scope**)
- Using external code (**`import`**)
- Understanding common `errors`

With these fundamentals, you are well-prepared to tackle the more domain-specific tools used in urban analysis.
